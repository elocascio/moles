import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import base64
from io import BytesIO


def clean_xvg(xvg):
    a = []
    b = []
    with open(xvg) as xvg:
        lines = xvg.readlines()
        for line in lines:
            if line.startswith("#") or line.startswith("@"):
                pass
            else:
                x, y = line.split()

                a.append(float(x))
                b.append(float(y))
    a = np.array(a)
    b = np.array(b)
    return a, b


def plot_xvg(xvg, title, filename, xlabel="x", ylabel="y"):
    """plot xvg file generated by gromacs and save image
        xvg: path of file xvg
        title: title of the plot
        xlabel
        ylabel
        
        return
            array1, array2, image base64 decoded"""
    a = []
    b = []
    with open(xvg) as xvg:
        for line in xvg.readlines():
            if line.startswith("#") or line.startswith("@"):
                pass
            else:
                x = line.split()
                a.append(float(x[0]))
                b.append(float(x[1]))
        a = np.array(a)
        b = np.array(b)
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.plot(a / 1000, b)
        plt.savefig(filename, format="png", dpi=600)
        figfile = BytesIO()
        plt.savefig(figfile, format="png")
        plt.close()
        figfile.seek(0)
        figdata_png = base64.b64encode(figfile.getvalue()).decode()
        plot_string = f'<img src="data:image/png;base64,{figdata_png}" /> '
    return a, b, plot_string


def detachmet(contacts):
    contacts_mean = np.mean(contacts)
    if (np.count_nonzero(contacts < 150) / contacts.shape[0]) > 0.40:
        status = "poor ligand"
        pass
    else:
        status = "attached"

    return status, contacts_mean


import yagmail


def send_mail(destination, subject, content, attachment):
    yag = yagmail.SMTP(user="dinamica.molecolare@gmail.com", password="AutoNotif1!")
    yag.send(
        to=destination, subject=subject, contents=content, attachments=attachment,
    )
    print("email sent")


######################### LOOKING FOR SMTH SMARTER ######################################
# import nvsmi
# def gpu_manager():
#    ids = []
#    for process in nvsmi.get_gpu_processes():
#        gpu_id = int(str(process).split('gpu_id: ')[-1].split(' | ')[0])
#        ids.append(gpu_id)
#    print(ids, ids.count(1), ids.count(0))
#    if len(ids) > 0:
#        if ids.count(0) == 0:
#            return 0
#        elif ids.count(1) / ids.count(0) > 1 or ids.count(0) == 0:
#            return 0
#        elif ids.count(1) / ids.count(0) < 1 or ids.count(1) == 0:
#            return 1
#        else:
#            return np.random.randint(2)
#    elif len(ids) == 0:
#        return 0
#    else:
#        return np.random.randint(2)
#########################################################################################

import MDAnalysis
from MDAnalysis.analysis import contacts
from io import BytesIO
import base64


def switch_function(r, r0, r_0=6, a=6, b=12):
    r = np.asarray(r)
    return np.sum((1 - (r / r_0) ** a) / (1 - (r / r_0) ** b))


from pymol import cmd
from itertools import cycle


def mutation(pdb, residues, mutation, pdb_out):
    cmd.wizard("mutagenesis")
    cmd.load(pdb)
    cmd.refresh_wizard()

    res_list = residues.split(",")
    res_cycle = cycle(res_list)
    aminoacid_list = mutation.split(",")
    amino_cycle = cycle(aminoacid_list)

    if len(res_list) != len(aminoacid_list):
        print("unmatchable items!")
        exit()

    for n in range(len(res_list)):
        chain, res = next(res_cycle).split("-")
        cmd.get_wizard().do_select(f"{chain}/{res}/")
        cmd.get_wizard().set_mode(next(amino_cycle).upper())
        cmd.get_wizard().apply()

    cmd.set_wizard()
    cmd.save(pdb_out)
    return pdb_out


class plane:
    def __init__(self, vectors):
        v1 = vectors[2] - vectors[0]
        v2 = vectors[1] - vectors[0]
        cp = np.cross(v1, v2)
        self.a = cp[0]
        self.b = cp[1]
        self.c = cp[2]
        self.d = np.dot(cp, vectors[2])
        self.v = cp
        self.center = (vectors[0] + vectors[1] + vectors[2]) / 3


# angolo indidenza tra piani, accetta classe plane
def theta(x, y):
    l = []
    for a, b in list(zip(x, y)):
        l.append(a * b)
    cross = sum(l)
    n1 = np.sqrt(x.a ** 2 + x.b ** 2 + x.c ** 2)
    n2 = np.sqrt(y.a ** 2 + y.b ** 2 + y.c ** 2)
    cos = cross / (n1 * n2)
    theta = np.arccos(cos)
    return theta


def picat(pos, ring):
    l, m, n = ring.center - pos
    numerator = abs(ring.a * l + ring.b * m + ring.c * n)
    denominator = np.sqrt(ring.a ** 2 + ring.b ** 2 + ring.c ** 2) * np.sqrt(
        l ** 2 + m ** 2 + n ** 2
    )
    return np.arcsin(numerator / denominator)
